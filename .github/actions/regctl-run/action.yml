name: Run regctl commands
description: Execute regctl commands from structured configuration

inputs:
  operations:
    description: |
      JSON/YAML array of regctl operations. Format:
      [
        {
          "type": "image-import",
          "tag": "registry/image:tag",
          "source": "path/to/oci.tar"
        },
        {
          "type": "manifest-put",
          "tag": "registry/image:tag",
          "sources": ["registry/image:tag-amd64", "registry/image:tag-arm64"]
        },
        {
          "type": "image-copy",
          "source": "registry/image:tag",
          "destination": "registry/image:newtag"
        },
        {
          "type": "tag-delete",
          "tag": "registry/image:tag"
        }
      ]
    required: true

  dry-run:
    description: 'Run in dry-run mode (only print commands)'
    required: false
    default: 'false'

  continue-on-error:
    description: 'Continue processing operations even if one fails'
    required: false
    default: 'false'

outputs:
  results:
    description: 'JSON array of operation results'
    value: ${{ steps.results.outputs.value }}

  success-count:
    description: 'Number of successful operations'
    value: ${{ steps.summary.outputs.success }}

  failure-count:
    description: 'Number of failed operations'
    value: ${{ steps.summary.outputs.failure }}

runs:
  using: 'composite'
  steps:
    - name: Debug operations input
      shell: bash
      run: |
        echo "::group::Operations to execute"
        echo '${{ inputs.operations }}' | jq .
        echo "::endgroup::"

    - name: Initialize results file
      shell: bash
      run: |
        echo '[]' > /tmp/regctl_results.json
        echo "Results file initialized at: $(date)"
        ls -la /tmp/regctl_results.json

    - name: Execute regctl operations
      uses: envoyproxy/toolshed/gh-actions/bson@actions-v0.3.23
      id: execute
      with:
        title: Execute regctl operations
        input: |
          operations: ${{ inputs.operations }}
          dry_run: ${{ inputs.dry-run }}
          continue_on_error: ${{ inputs.continue-on-error }}
        input-format: yaml
        catch-errors: ${{ inputs.continue-on-error }}
        filter: |
          .dry_run as $dry_run |
          .continue_on_error as $continue_on_error |

          "# Initialize results\n" +
          "RESULTS_FILE=/tmp/regctl_results.json\n" +
          "echo '[]' > \"$RESULTS_FILE\"\n\n" +

          "# Function to add result\n" +
          "add_result() {\n" +
          "    local type=\"$1\"\n" +
          "    local tag=\"$2\"\n" +
          "    local success=\"$3\"\n" +
          "    local message=\"$4\"\n" +
          "    jq --arg type \"$type\" --arg tag \"$tag\" --arg success \"$success\" --arg msg \"$message\" \\\n" +
          "       '. += [{type: $type, tag: $tag, success: ($success == \"true\"), message: $msg}]' \\\n" +
          "       \"$RESULTS_FILE\" > \"${RESULTS_FILE}.tmp\" && mv \"${RESULTS_FILE}.tmp\" \"$RESULTS_FILE\"\n" +
          "}\n\n" +

          (.operations[] |
            . as $op |

            # Handle image-import
            (if .type == "image-import" then
              "echo \"::group::Import \(.tag)\"\n" +
              "if [[ '\($dry_run)' == 'true' ]]; then\n" +
              "    echo '[DRY RUN] Would import OCI archive '\(.source | @sh)' as '\(.tag | @sh)'\n" +
              "    add_result 'image-import' '\(.tag)' true '[DRY RUN] Would import'\n" +
              "else\n" +
              "    echo 'Importing OCI archive '\(.source | @sh)' to local OCI directory'\n" +
              "    # Import to local ocidir:// instead of pushing to registry\n" +
              "    # Use a simpler tag format that preserves the original structure\n" +
              "    LOCAL_TAG=$(echo '\(.tag)' | sed 's|[:/]|_|g')\n" +
              "    LOCAL_DIR=\"/tmp/ocidir/${LOCAL_TAG}\"\n" +
              "    \n" +
              "    # Ensure clean state\n" +
              "    rm -rf \"${LOCAL_DIR}\" 2>/dev/null || true\n" +
              "    mkdir -p \"/tmp/ocidir\"\n" +
              "    \n" +
              "    echo \"  Source: \(.source)\"\n" +
              "    echo \"  Target: ocidir://${LOCAL_DIR}\"\n" +
              "    \n" +
              "    # Import using regctl\n" +
              "    if regctl image import \"ocidir://${LOCAL_DIR}\" '\(.source)' 2>&1; then\n" +
              "        echo \"  ✓ Successfully imported\"\n" +
              "        # Store mapping for later reference\n" +
              "        echo '\(.tag)'>${LOCAL_DIR}/.original_tag\n" +
              "        add_result 'image-import' '\(.tag)' true 'Successfully imported to local OCI directory'\n" +
              "    else\n" +
              "        echo \"::error::Failed to import \(.source)\"\n" +
              "        add_result 'image-import' '\(.tag)' false 'Failed to import - see logs above'\n" +
              (if $continue_on_error then "" else "        exit 1\n" end) +
              "    fi\n" +
              "fi\n" +
              "echo '::endgroup::'\n"
            else empty end) +

            # Handle manifest-put
            (if .type == "manifest-put" then
              "echo \"::group::Create manifest \(.tag)\"\n" +
              "if [[ '\($dry_run)' == 'true' ]]; then\n" +
              "    echo '[DRY RUN] Would create manifest '\(.tag | @sh)' from: '\(.sources | join(" ") | @sh)'\n" +
              "    add_result 'manifest-put' '\(.tag)' true '[DRY RUN] Would create manifest'\n" +
              "else\n" +
              "    echo 'Creating manifest '\(.tag | @sh)' from local OCI references'\n" +
              "    # Build list of local ocidir:// references\n" +
              "    LOCAL_REFS=()\n" +
              "    MISSING_REFS=()\n" +
              "    echo \"  Searching for architecture images:\"\n" +
              (.sources[] as $source |
                "    LOCAL_TAG=$(echo '\($source)' | sed 's|[:/]|_|g')\n" +
                "    LOCAL_DIR=\"/tmp/ocidir/${LOCAL_TAG}\"\n" +
                "    if [[ -d \"${LOCAL_DIR}\" ]]; then\n" +
                "        LOCAL_REFS+=(\"ocidir://${LOCAL_DIR}\")\n" +
                "        echo \"    ✓ Found: \($source) → ocidir://${LOCAL_DIR}\"\n" +
                "    else\n" +
                "        MISSING_REFS+=(\"\($source)\")\n" +
                "        echo \"    ✗ Missing: \($source)\"\n" +
                "    fi\n"
              ) +
              "    \n" +
              "    if [[ ${#LOCAL_REFS[@]} -eq 0 ]]; then\n" +
              "        echo \"::error::No local references found for manifest \(.tag)\"\n" +
              "        echo \"  Expected sources: \(.sources | join(", "))\"\n" +
              "        echo \"  Contents of /tmp/ocidir:\"\n" +
              "        ls -la /tmp/ocidir/ 2>/dev/null || echo \"    Directory not found\"\n" +
              "        add_result 'manifest-put' '\(.tag)' false 'No local references found'\n" +
              (if $continue_on_error then "" else "        exit 1\n" end) +
              "    elif [[ ${#MISSING_REFS[@]} -gt 0 ]]; then\n" +
              "        echo \"::warning::Some architectures missing: ${MISSING_REFS[@]}\"\n" +
              "        echo \"  Proceeding with ${#LOCAL_REFS[@]} available architectures\"\n" +
              "    fi\n" +
              "    \n" +
              "    if [[ ${#LOCAL_REFS[@]} -gt 0 ]]; then\n" +
              "        echo \"  Creating manifest from ${#LOCAL_REFS[@]} architectures\"\n" +
              "        \n" +
              "        # Create manifest directly at the target registry\n" +
              "        echo \"  Running: regctl manifest put '\(.tag)' ${LOCAL_REFS[@]}\"\n" +
              "        if regctl manifest put '\(.tag)' ${LOCAL_REFS[@]} 2>&1; then\n" +
              "            echo \"  ✓ Manifest created and pushed successfully\"\n" +
              "            add_result 'manifest-put' '\(.tag)' true 'Successfully created and pushed manifest'\n" +
              "        else\n" +
              "            echo \"::error::Failed to create manifest \(.tag)\"\n" +
              "            add_result 'manifest-put' '\(.tag)' false 'Failed to create manifest'\n" +
              (if $continue_on_error then "" else "            exit 1\n" end) +
              "        fi\n" +
              "    fi\n" +
              "fi\n" +
              "echo '::endgroup::'\n"
            else empty end) +

            # Handle image-copy
            (if .type == "image-copy" then
              "echo \"::group::Copy \(.source) to \(.destination)\"\n" +
              "if [[ '\($dry_run)' == 'true' ]]; then\n" +
              "    echo '[DRY RUN] Would copy '\(.source | @sh)' to '\(.destination | @sh)'\n" +
              "    add_result 'image-copy' '\(.destination)' true '[DRY RUN] Would copy'\n" +
              "else\n" +
              "    echo 'Copying '\(.source | @sh)' to '\(.destination | @sh)'\n" +
              "    if regctl image copy '\(.source)' '\(.destination)'; then\n" +
              "        add_result 'image-copy' '\(.destination)' true 'Successfully copied'\n" +
              "    else\n" +
              "        echo \"::error::Failed to copy \(.source) to \(.destination)\"\n" +
              "        add_result 'image-copy' '\(.destination)' false 'Failed to copy - see logs above'\n" +
              (if $continue_on_error then "" else "        exit 1\n" end) +
              "    fi\n" +
              "fi\n" +
              "echo '::endgroup::'\n"
            else empty end) +

            # Handle tag-delete
            (if .type == "tag-delete" then
              "echo \"::group::Delete tag \(.tag)\"\n" +
              "if [[ '\($dry_run)' == 'true' ]]; then\n" +
              "    echo '[DRY RUN] Would delete tag '\(.tag | @sh)'\n" +
              "    add_result 'tag-delete' '\(.tag)' true '[DRY RUN] Would delete'\n" +
              "else\n" +
              "    echo 'Deleting tag '\(.tag | @sh)'\n" +
              "    if regctl tag delete '\(.tag)' || true; then\n" +
              "        add_result 'tag-delete' '\(.tag)' true 'Successfully deleted or already gone'\n" +
              "    else\n" +
              "        add_result 'tag-delete' '\(.tag)' false 'Failed to delete'\n" +
              (if $continue_on_error then "" else "        exit 1\n" end) +
              "    fi\n" +
              "fi\n" +
              "echo '::endgroup::'\n"

            else
              "echo \"::warning::Unknown operation type: \(.type)\"\n"
            end)
          ) +

          "\n# Output results\n" +
          "echo 'Operations completed. Results file contents:'\n" +
          "if [[ -f \"$RESULTS_FILE\" ]]; then\n" +
          "    cat \"$RESULTS_FILE\"\n" +
          "else\n" +
          "    echo 'ERROR: Results file not found!'\n" +
          "    echo '[]' > \"$RESULTS_FILE\"\n" +
          "    cat \"$RESULTS_FILE\"\n" +
          "fi\n"

    - name: Run operations script
      shell: bash
      run: |
        # Execute the generated script
        cat << 'EOF' | bash -ex
        ${{ steps.execute.outputs.value }}
        EOF

    - name: Read results
      id: results
      uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
      with:
        input-format: json-path
        input: /tmp/regctl_results.json
        filter: .

    - name: Calculate summary
      id: calc-summary
      uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
      with:
        input: ${{ steps.results.outputs.value }}
        filter: |
          {
            success: (map(select(.success)) | length),
            failure: (map(select(.success | not)) | length)
          }
        output-path: /tmp/regctl_summary.json

    - name: Extract counts
      shell: bash
      run: |
        SUCCESS=$(jq -r '.success' /tmp/regctl_summary.json)
        FAILURE=$(jq -r '.failure' /tmp/regctl_summary.json)
        echo "success=$SUCCESS" >> $GITHUB_OUTPUT
        echo "failure=$FAILURE" >> $GITHUB_OUTPUT
      id: summary

    - name: Display error summary
      if: steps.summary.outputs.failure != '0'
      uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
      with:
        input: ${{ steps.results.outputs.value }}
        filter: |
          "::error::Operation failures detected!\n" +
          "\n=== FAILED OPERATIONS ===\n" +
          (map(select(.success | not) |
            "  \(.type) \(.tag): \(.message)")
          | join("\n")) +
          "\n\n=== SUMMARY ===\n" +
          "Total operations: " + (length | tostring) + "\n" +
          "Successful: " + (map(select(.success)) | length | tostring) + "\n" +
          "Failed: " + (map(select(.success | not)) | length | tostring)
        options: -r
        print-output: true

    - name: Fail if any operations failed
      if: steps.summary.outputs.failure != '0'
      shell: bash
      run: |
        echo "::error::${{ steps.summary.outputs.failure }} operations failed"
        exit 1
