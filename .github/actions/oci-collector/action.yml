name: 'OCI Artifact Collector'
description: 'Collect OCI artifacts and push multi-arch manifests to registries using regctl'
author: 'Envoy Build Tools'

inputs:
  artifacts-pattern:
    description: 'Pattern to match artifact names (e.g., "oci-*")'
    required: false
    default: 'oci-*'
  artifacts-path:
    description: 'Path to download artifacts to'
    required: false
    default: './oci-images'
  manifest-config:
    description: |
      JSON configuration for manifests to create. Format:
      {
        "manifests": [
          {
            "name": "my-image",
            "tag": "latest",
            "registry": "docker.io/myorg",
            "architectures": ["amd64", "arm64"],
            "artifact-pattern": "{arch}/myimage-{arch}.tar",
            "push": true
          }
        ]
      }
    required: true
  dry-run:
    description: 'Run without actually pushing images'
    required: false
    default: 'false'
  dockerhub-username:
    description: 'Docker Hub username'
    required: false
    default: ''
  dockerhub-password:
    description: 'Docker Hub password'
    required: false
    default: ''
  gcr-service-account-key:
    description: 'GCP service account key (base64 encoded)'
    required: false
    default: ''

outputs:
  pushed-manifests:
    description: 'JSON array of pushed manifest tags'
    value: ${{ steps.final-pushed.outputs.value }}
  manifest-details:
    description: 'JSON object with detailed manifest information'
    value: ${{ steps.final-details.outputs.value }}


runs:
  using: 'composite'
  steps:
  - name: Install regctl
    uses: envoyproxy/toolshed/gh-actions/regctl/install@88e79ab6754da224a2b60f4dcad7c3cd10bec6d6
  - name: Download OCI artifacts
    uses: actions/download-artifact@v4
    with:
      pattern: ${{ inputs.artifacts-pattern }}
      path: ${{ inputs.artifacts-path }}
  - name: Authenticate regctl
    uses: envoyproxy/toolshed/gh-actions/regctl/auth@dfe34f8e6900faae9e22f4ec37f12eb721cf93b2
    with:
      dockerhub-username: ${{ inputs.dockerhub-username }}
      dockerhub-password: ${{ inputs.dockerhub-password }}
      gcr-service-account-key: ${{ inputs.gcr-service-account-key }}

  - name: Initialize result files
    shell: bash
    run: |
      echo '[]' > /tmp/regctl_operations.json
      echo '[]' > /tmp/pushed_manifests.json
      echo '{}' > /tmp/manifest_details.json

  - name: Build regctl operations
    uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
    id: operations
    with:
      input: |
        config: ${{ inputs.manifest-config }}
        artifacts_path: ${{ inputs.artifacts-path }}
      input-format: yaml
      filter: |
        .artifacts_path as $artifacts_path |
        [
          .config.manifests[] |
          . as $manifest |
          .registry as $registry |
          .name as $name |
          .tag as $tag |
          "\(.registry)/\(.name):\(.tag)" as $manifest_tag |
          (.push // true) as $push |
          ."artifact-pattern" as $pattern |
          (.["additional-tags"] // []) as $additional_tags |

          # Generate import operations for each architecture
          (.architectures[] as $arch |
            {
              type: "image-import",
              tag: "\($manifest_tag)-\($arch)",
              source: "\($artifacts_path)/\($pattern | gsub("{arch}"; $arch))",
              metadata: {
                manifest: $name,
                manifest_tag: $manifest_tag,
                arch: $arch,
                push: $push
              }
            }
          ),

          # Generate manifest-put operation if push is true
          (if $push then
            {
              type: "manifest-put",
              tag: $manifest_tag,
              sources: [.architectures[] as $arch | "\($manifest_tag)-\($arch)"],
              metadata: {
                manifest: $name,
                architectures: .architectures
              }
            }
          else empty end),

          # Generate cleanup operations for arch tags
          (if $push then
            (.architectures[] as $arch |
              {
                type: "tag-delete",
                tag: "\($manifest_tag)-\($arch)",
                metadata: {
                  cleanup: true
                }
              }
            )
          else empty end),

          # Generate copy operations for additional tags
          (if $push and (($additional_tags | length) > 0) then
            ($additional_tags[] as $tag |
              {
                type: "image-copy",
                source: $manifest_tag,
                destination: "\($registry)/\($name):\($tag)",
                metadata: {
                  additional_tag: true
                }
              }
            )
          else empty end)
        ]
      output-path: /tmp/regctl_operations.json

  - name: Execute regctl operations
    uses: ./.github/actions/regctl-run
    id: regctl
    with:
      operations: ${{ steps.operations.outputs.value }}
      dry-run: ${{ inputs.dry-run }}
      continue-on-error: 'true'

  - name: Process results
    uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
    id: process-results
    with:
      input: |
        operations: ${{ steps.operations.outputs.value }}
        results: ${{ steps.regctl.outputs.results }}
      input-format: yaml
      filter: |
        # Build lookup of results by tag
        (.results | map({key: .tag, value: .}) | from_entries) as $results |

        # Process operations to build outputs
        .operations |
        reduce .[] as $op (
          {pushed: [], details: {}};

          # Track successful manifest-put operations
          if $op.type == "manifest-put" and $results[$op.tag].success then
            .pushed += [$op.tag]
          else . end |

          # Track successful image-copy operations (additional tags)
          if $op.type == "image-copy" and $op.metadata.additional_tag and $results[$op.destination].success then
            .pushed += [$op.destination]
          else . end |

          # Build manifest details from manifest-put operations
          if $op.type == "manifest-put" then
            .details[$op.metadata.manifest + ":" + ($op.tag | split(":")[-1])] = {
              tag: $op.tag,
              architectures: $op.metadata.architectures,
              pushed: $results[$op.tag].success
            }
          else . end
        ) |
        {
          pushed_manifests: (.pushed | unique),
          manifest_details: .details
        }
      output-path: /tmp/final_results.json

  - name: Final pushed manifests
    id: final-pushed
    uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
    with:
      input-format: json-path
      input: /tmp/pushed_manifests.json
      filter: |
        .

  - name: Final manifest details
    id: final-details
    uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
    with:
      input-format: json-path
      input: /tmp/manifest_details.json
      filter: |
        .

  - name: Summary
    uses: envoyproxy/toolshed/gh-actions/jq@actions-v0.3.23
    with:
      input: |
        pushed: ${{ steps.final-pushed.outputs.value }}
        details: ${{ steps.final-details.outputs.value }}
      input-format: yaml
      filter: |
        "Manifest collection complete!" as $title
        | "\nPushed manifests:" as $pushed_title
        | (.pushed | tojson) as $pushed_json
        | "\nManifest details:" as $details_title
        | (.details | tojson) as $details_json
        | [$title, $pushed_title, $pushed_json, $details_title, $details_json]
        | join("\n")
      options: -r
      print-output: true
